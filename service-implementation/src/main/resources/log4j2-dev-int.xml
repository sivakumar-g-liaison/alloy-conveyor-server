<?xml version="1.0" encoding="UTF-8"?>
<!-- Copyright 2014 Liaison Technologies, Inc. This software is the confidential 
	and proprietary information of Liaison Technologies, Inc. ("Confidential 
	Information"). You shall not disclose such Confidential Information and shall 
	use it only in accordance with the terms of the license agreement you entered 
	into with Liaison Technologies. -->
	
<configuration status="INFO"
	packages="com.liaison.common.log4j2.plugins,com.liaison.commons.log4j2,net.logstash.logging.log4j2.core.layout,com.liaison.commons.audit.log4j2"
	verbose="true" monitorInterval="${sys:com.liaison.log4j2.configuration.refresh.interval.sec}">

	<appenders>


		<!-- ############################################################## -->
		<!-- ######### Logstash, General Application Logs ############ -->
		<!-- ############################################################## -->

		<!-- LogStashSocket is a tcp socket dumping logstash spec 1.0 messages -->
		<Socket name="LogStashSocket" host="${env:LOGSTASHMACHINE}"
			port="${env:LOGSTASHPORT}" connectTimeoutMillis="500"
			reconnectionDelayMillis="500" immediateFail="true" protocol="tcp"
			ignoreExceptions="false">
			<!-- exclude redundant log element -->
			<LogStashJSONLayout excludeLog="true">

				<!-- Provide ANY type of layout to expose the message, being mindful 
					that if -->
				<!-- subLayoutAsElement="true", your (likely custom) Layout will need 
					to -->
				<!-- produce a valid and escaped json element -->
				<PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %level %logger{36} - %msg" />

				<!-- helpful sort filter -->
				<KeyValuePair key="layout" value="log4j2_event_json" />


				<!-- Archaius Properties -->
				<KeyValuePair key="deployment_environment"
					value="${sys:archaius.deployment.environment}" />
				<KeyValuePair key="deployment_datacenter"
					value="${sys:archaius.deployment.datacenter}" />
				<KeyValuePair key="deployment_applicationId"
					value="${sys:archaius.deployment.applicationId}" />
				<KeyValuePair key="deployment_serverId" value="${sys:archaius.deployment.serverId}" />
				<KeyValuePair key="deployment_stack" value="${sys:archaius.deployment.stack}" />
				<KeyValuePair key="deployment_region" value="${sys:archaius.deployment.region}" />

				<!-- AppEnv set properties -->
				<KeyValuePair key="host_ips" value="${env:HOST_IPS}" />
				<KeyValuePair key="hostname" value="${env:LOCAL_HOSTNAME}" />
				<KeyValuePair key="environment_user" value="${env:DAEMON_USER}" />
				<KeyValuePair key="login_user" value="${env:LOGIN_USER}" />

				<!-- jre properties -->
				<KeyValuePair key="java_version" value="${sys:java.version}" />

			</LogStashJSONLayout>
			<filters>
				<!-- remove some noise -->
				<MarkerFilter marker="MARKER_HQ_CLIENT_POOL" onMatch="DENY"
					onMismatch="ACCEPT" />
				<MarkerFilter marker="SPECTRUM_CLIENT" onMatch="DENY"
					onMismatch="ACCEPT" />
			</filters>

		</Socket>


		<!-- destination of failover when logstash socket fails -->
		<RollingFile name="LogStashFailoverFile"
			fileName="${env:LOGSTASH_LOG_DIR}/logstash.failover.log"
			filePattern="${env:LOGSTASH_LOG_DIR}/logstash.failover-%d{MM-dd-yyyy}.log.gz"
			ignoreExceptions="false">
			<!-- exclude redundant log element -->
			<LogStashJSONLayout excludeLog="true">

				<!-- Provide ANY type of layout to expose the message, being mindful 
					that if -->
				<!-- subLayoutAsElement="true", your (likely custom) Layout will need 
					to -->
				<!-- produce a valid and escaped json element -->
				<PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %level %logger{36} - %msg" />

				<!-- helpful sort filter -->
				<KeyValuePair key="layout" value="log4j2_event_json" />


				<!-- Archaius Properties -->
				<KeyValuePair key="deployment_environment"
					value="${sys:archaius.deployment.environment}" />
				<KeyValuePair key="deployment_datacenter"
					value="${sys:archaius.deployment.datacenter}" />
				<KeyValuePair key="deployment_applicationId"
					value="${sys:archaius.deployment.applicationId}" />
				<KeyValuePair key="deployment_serverId" value="${sys:archaius.deployment.serverId}" />
				<KeyValuePair key="deployment_stack" value="${sys:archaius.deployment.stack}" />
				<KeyValuePair key="deployment_region" value="${sys:archaius.deployment.region}" />

				<!-- AppEnv set properties -->
				<KeyValuePair key="host_ips" value="${env:HOST_IPS}" />
				<KeyValuePair key="hostname" value="${env:LOCAL_HOSTNAME}" />
				<KeyValuePair key="environment_user" value="${env:DAEMON_USER}" />
				<KeyValuePair key="login_user" value="${env:LOGIN_USER}" />

				<!-- jre properties -->
				<KeyValuePair key="java_version" value="${sys:java.version}" />

			</LogStashJSONLayout>
			<filters>
				<!-- remove some noise -->
				<MarkerFilter marker="MARKER_HQ_CLIENT_POOL" onMatch="DENY"
					onMismatch="ACCEPT" />
				<MarkerFilter marker="SPECTRUM_CLIENT" onMatch="DENY"
					onMismatch="ACCEPT" />
			</filters>

			<Policies>
				<TimeBasedTriggeringPolicy />
				<SizeBasedTriggeringPolicy size="${env:LOGSTASH_ROLLING_SIZE}" />
			</Policies>
		</RollingFile>

		<!-- Failover when either logstash socket appender fails or we run out 
			of slots in buffer (overrun) -->
		<Async name="AsyncLogStashSocketWithFailover" blocking="false"
			bufferSize="${env:LOGSTASH_RING_BUFFER_SIZE}" errorRef="LogStashFailoverFile"
			ignoreExceptions="false">
			<AppenderRef ref="LogStashSocket" />
		</Async>

		<!-- If the Async appender itself dies (ring buffer thread dies), finally 
			fail to console -->
		<Failover name="AsyncLogStashSocketWithFailoverFailover"
			primary="AsyncLogStashSocketWithFailover">
			<Failovers>
				<AppenderRef ref="Console" />
			</Failovers>
		</Failover>



		<!-- ############################################################## -->
		<!-- ######### Organization GSA APPENDER ############ -->
		<!-- ############################################################## -->

		<!-- primary appender to lens -->
		<GSAMessageLENS name="OrgGSALENSAppender" ip="${env:GSA_LENS_IP}"
			topic="OrganizationData" ignoreExceptions="false">
			<GSAMessageXMLLayout />
			<filters>
				<MarkerFilter marker="ORGANIZATION_GSA_MARKER" onMatch="ACCEPT"
					onMismatch="DENY" />
			</filters>
		</GSAMessageLENS>


		<!-- failover destination -->
		<RollingFile name="OrgGSALENSAppenderFailoverFile"
			fileName="${env:LENS_LOG_DIR}/OrgGSALENSAppender.failover.log"
			filePattern="${env:LENS_LOG_DIR}/OrgGSALENSAppender.failover-%d{MM-dd-yyyy}.log.gz"
			ignoreExceptions="false">
			<GSAMessageXMLLayout />
			<filters>
				<MarkerFilter marker="ORGANIZATION_GSA_MARKER" onMatch="ACCEPT"
					onMismatch="DENY" />
			</filters>

			<Policies>
				<TimeBasedTriggeringPolicy />
				<SizeBasedTriggeringPolicy size="${env:ORGANIZATION_GSA_ROLLING_SIZE}" />
			</Policies>
		</RollingFile>

		<!-- Failover when either LENS appender fails or we run out of slots in 
			buffer (overrun) -->
		<Async name="AsyncOrgGSALENSAppenderWithFailover" blocking="false"
			bufferSize="${env:ORGANIZATION_GSA_RING_BUFFER_SIZE}" errorRef="OrgGSALENSAppenderFailoverFile"
			ignoreExceptions="false">
			<AppenderRef ref="OrgGSALENSAppender" />
		</Async>

		<!-- If the Async appender itself dies (ring buffer thread dies), finally 
			fail to console -->
		<Failover name="AsyncOrgGSALENSAppenderWithFailoverFailover"
			primary="AsyncOrgGSALENSAppenderWithFailover">
			<Failovers>
				<AppenderRef ref="Console" />
			</Failovers>
		</Failover>


		<!-- ############################################################## -->
		<!-- ######### Pairwise GSA APPENDER ############ -->
		<!-- ############################################################## -->

		<GSAMessageLENS name="PairwiseGSALENSAppender" ip="${env:GSA_LENS_IP}"
			topic="PairwiseData">
			<GSAMessageXMLLayout />
			<filters>
				<MarkerFilter marker="PAIRWISE_GSA_MARKER" onMatch="ACCEPT"
					onMismatch="DENY" />
			</filters>
		</GSAMessageLENS>


		<!-- failover destination -->
		<RollingFile name="PairwiseGSALENSAppenderFailoverFile"
			fileName="${env:LENS_LOG_DIR}/PairwiseGSALENSAppender.failover.log"
			filePattern="${env:LENS_LOG_DIR}/PairwiseGSALENSAppender.failover-%d{MM-dd-yyyy}.log.gz"
			ignoreExceptions="false">
			<GSAMessageXMLLayout />
			<filters>
				<MarkerFilter marker="PAIRWISE_GSA_MARKER" onMatch="ACCEPT"
					onMismatch="DENY" />
			</filters>

			<Policies>
				<TimeBasedTriggeringPolicy />
				<SizeBasedTriggeringPolicy size="${env:PAIRWISE_GSA_ROLLING_SIZE}" />
			</Policies>
		</RollingFile>

		<!-- Failover when either LENS appender fails or we run out of slots in 
			buffer (overrun) -->
		<Async name="AsyncPairwiseGSALENSAppenderWithFailover" blocking="false"
			bufferSize="${env:PAIRWISE_GSA_RING_BUFFER_SIZE}" errorRef="PairwiseGSALENSAppenderFailoverFile"
			ignoreExceptions="false">
			<AppenderRef ref="PairwiseGSALENSAppender" />
		</Async>

		<!-- If the Async appender itself dies (ring buffer thread dies), finally 
			fail to console -->
		<Failover name="AsyncPairwiseGSALENSAppenderWithFailoverFailover"
			primary="AsyncPairwiseGSALENSAppenderWithFailover">
			<Failovers>
				<AppenderRef ref="Console" />
			</Failovers>
		</Failover>





		<!-- ############################################################## -->
		<!-- ######### Glass Message General ############ -->
		<!-- ############################################################## -->

		<!-- Logs ONLY Glass Messages to Spectrum -->
		<GlassMessageSpectrum name="GlassMessageSpectrumREST"
			ip="${env:GLASS_SPECTRUM_IP}" port="${env:GLASS_SPECTRUM_PORT}"
			password="${env:GLASS_SPECTRUM_PASSWORD}" username="${env:GLASS_SPECTRUM_USER}"
			sourceName="${env:GLASS_SPECTRUM_SOURCE_NAME}" messageTTL="${env:GLASS_SPECTRUM_MESSAGE_TTL}"
			dataSpaceName="${env:GLASS_SPECTRUM_DATASPACE}">
			<GlassMessageJSONLayout compact="true" />
			<filters>
				<MarkerFilter marker="GLASS_MESSAGE_MARKER" onMatch="ACCEPT"
					onMismatch="DENY" />
			</filters>
		</GlassMessageSpectrum>

		<!-- failover destination -->
		<RollingFile name="GlassMessageSpectrumFile"
			fileName="${env:GLASS_LOG_DIR}/GlassMessageSpectrumREST.failover.log"
			filePattern="${env:GLASS_LOG_DIR}/GlassMessageSpectrumREST.failover-%d{MM-dd-yyyy}.log.gz"
			ignoreExceptions="false">
			<GlassMessageJSONLayout compact="true" />
			<filters>
				<MarkerFilter marker="GLASS_MESSAGE_MARKER" onMatch="ACCEPT"
					onMismatch="DENY" />
			</filters>

			<Policies>
				<TimeBasedTriggeringPolicy />
				<SizeBasedTriggeringPolicy size="${env:GLASS_ROLLING_SIZE}" />
			</Policies>
		</RollingFile>

		<!-- Failover when either GlassMessageSpectrumREST appender fails or we 
			run out of slots in buffer (overrun) -->
		<Async name="AsyncGlassMessageSpectrumRESTWithFailover"
			blocking="false" bufferSize="${env:GLASS_RING_BUFFER_SIZE}" errorRef="GlassMessageSpectrumFile"
			ignoreExceptions="false">
			<AppenderRef ref="GlassMessageSpectrumREST" />
		</Async>

		<!-- If the Async appender itself dies (ring buffer thread dies), finally 
			fail to console -->
		<Failover name="AsyncGlassMessageSpectrumRESTWithFailoverFailover"
			primary="AsyncGlassMessageSpectrumRESTWithFailover">
			<Failovers>
				<AppenderRef ref="Console" />
			</Failovers>
		</Failover>



		<!-- ############################################################## -->
		<!-- ######### Glass Message Metrics ############ -->
		<!-- ############################################################## -->

		<GlassMessageSpectrum name="MetricsGMSpectrumAppender"
			ip="${env:GLASS_METRIC_IP}" port="${env:GLASS_METRIC_PORT}" password="${env:GLASS_METRIC_PASSWORD}"
			username="${env:GLASS_METRIC_USER}" dataSpaceName="${env:GLASS_METRIC_DATASPACE}"
			sourceName="${env:GLASS_METRIC_SOURCE_NAME}" messageTTL="${env:GLASS_METRIC_TTL}"
			dataObjectName="${env:GLASS_METRIC_DATAOBJECTNAME}">
			<GlassMessageJSONLayout compact="true" />
			<filters>
				<MarkerFilter marker="METRICS_GM_MARKER" onMatch="ACCEPT"
					onMismatch="DENY" />
			</filters>
		</GlassMessageSpectrum>

		<!-- failover destination -->
		<RollingFile name="MetricsGMSpectrumFile"
			fileName="${env:METRICS_LOG_DIR}/MetricsGMSpectrum.failover.log"
			filePattern="${env:METRICS_LOG_DIR}/MetricsGMSpectrum.failover-%d{MM-dd-yyyy}.log.gz"
			ignoreExceptions="false">
			<GlassMessageJSONLayout compact="true" />
			<filters>
				<MarkerFilter marker="METRICS_GM_MARKER" onMatch="ACCEPT"
					onMismatch="DENY" />
			</filters>

			<Policies>
				<TimeBasedTriggeringPolicy />
				<SizeBasedTriggeringPolicy size="${env:METRICS_ROLLING_SIZE}" />
			</Policies>
		</RollingFile>

		<!-- Failover when either MetricsGMSpectrumAppender appender fails or we 
			run out of slots in buffer (overrun) -->
		<Async name="AsyncMetricsGMSpectrumAppenderWithFailover"
			blocking="false" bufferSize="${env:METRICS_RING_BUFFER_SIZE}"
			errorRef="MetricsGMSpectrumFile" ignoreExceptions="false">
			<AppenderRef ref="MetricsGMSpectrumAppender" />
		</Async>

		<!-- If the Async appender itself dies (ring buffer thread dies), finally 
			fail to console -->
		<Failover name="AsyncMetricsGMSpectrumAppenderWithFailoverFailover"
			primary="AsyncMetricsGMSpectrumAppenderWithFailover">
			<Failovers>
				<AppenderRef ref="Console" />
			</Failovers>
		</Failover>

		<!-- ############################################################## -->
		<!-- ######### Console ############ -->
		<!-- ############################################################## -->

		<Console name="Console" target="SYSTEM_OUT" ignoreExceptions="true">
			<PatternLayout
				pattern="%highlight{%d %c{1.} [%t] %-5level: %msg | %X%x%n%throwable}" />
			<filters>
				<!-- remove some noise -->
				<MarkerFilter marker="MARKER_HQ_CLIENT_POOL" onMatch="DENY"
					onMismatch="ACCEPT" />
				<MarkerFilter marker="SPECTRUM_CLIENT" onMatch="DENY"
					onMismatch="ACCEPT" />
			</filters>
		</Console>

	</appenders>

	<loggers>
		<root level="INFO">
			<appender-ref ref="AsyncLogStashSocketWithFailoverFailover" />
			<appender-ref ref="AsyncOrgGSALENSAppenderWithFailoverFailover" />
			<appender-ref ref="AsyncPairwiseGSALENSAppenderWithFailoverFailover" />
			<appender-ref ref="AsyncGlassMessageSpectrumRESTWithFailoverFailover" />
			<appender-ref ref="AsyncMetricsGMSpectrumAppenderWithFailoverFailover" />

			<!-- not for production -->
			<appender-ref ref="Console" />

		</root>
	</loggers>
</configuration>