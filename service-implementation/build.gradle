apply plugin: 'war'
apply plugin: 'jetty'
apply plugin: 'cargo'

// set base name (impacts war name and context path)
project.war.baseName = 'hello-world'

// Establish version and status
ext.githubProjectName = rootProject.name // Change if github project name is not the same as the root project's name

test {
    // TODO temp exclusion of j2ep
    exclude 'org/sf/j2ep/*'
}


buildscript {
    repositories { 
        mavenCentral() 
        maven { url "${thirdpartyArtifactRepoURL}" }              // for ojdbc6.jar
        maven { url 'http://www.eviware.com/repository/maven2/' } // for SoapUI
    }
    apply from: file("$rootDir/gradle/buildscript.gradle"), to: buildscript
    dependencies {
        // Cargo Plugin
        classpath 'org.gradle.api.plugins:gradle-cargo-plugin:0.6'
    }

}

allprojects {
    repositories { mavenCentral() }
	configurations.all {
		// This is an incubating gradle language feature (as of 1.5) allowing, in this 
		// case, for FOO.pom to be swapped for any sub-dependencies of BAR.pom.
	    resolutionStrategy.eachDependency { DependencyResolveDetails details ->
	        if (details.requested.name == 'slf4j-simple') {
	            //prefer 'slf4j-log4j2' over 'slf4j-simple', because
				//it's required that only one logger.jar be present for deterministic behavior of slf4j
				details.useTarget "org.apache.logging.log4j:log4j-slf4j-impl:2.0-beta7"
	        }

	
	    }
		
	}
}

war {

    from('resources') {
        include '*.properties'
        into 'WEB-INF/classes/'
    }

    // TODO
    // Resources used for the Dynamic Services landing page are intentionally kept in the
    // service-framework module (where dynamic services framework is also defined), and
    // outside of the service-implementation.  Eventually the service-framework will be an
    // artifact, and we will be unable to pull in resources like this.
    from("$rootDir/service-framework/src/main/resources") {
        include '**/**';
        into 'WEB-INF/classes/'
    }

    // TODO Needed?  I believe is is, since this is not
    // the conventional location for webapp root
    from('src/main/webapp/') {
        include '**/**';
        into '/'
    }

    //webXml = file('src/main/webapp/WEB-INF/web.xml')
}

dependencies {

	compile 'com.netflix.eureka:eureka-client:1.1.97'

	compile 'org.slf4j:slf4j-api:1.7.5'
	//compile 'org.slf4j:slf4j-log4j12:1.7.5'
	
	def log4j2Version = '2.0-beta7';
	compile "org.apache.logging.log4j:log4j-api:$log4j2Version"
	compile "org.apache.logging.log4j:log4j-core:$log4j2Version"
	compile "org.apache.logging.log4j:log4j-slf4j-impl:$log4j2Version"
	
    compile "com.netflix.karyon:karyon-extensions:${karyonVersion}" 

    compile project(':karyon-admin-web')
    compile project(':service-framework')

    // ************************************* beg cargo *********************************************
    def cargoVersion = "1.4.0"
    cargo "org.codehaus.cargo:cargo-core-uberjar:$cargoVersion",
            "org.codehaus.cargo:cargo-ant:$cargoVersion"
    // ************************************* end cargo *********************************************
}

// Cargo is a thin wrapper that allows you to manipulate Java EE containers in a standard way.
// http://cargo.codehaus.org/
// https://github.com/bmuschko/gradle-cargo-plugin
def installRootPath = "${rootDir}/install"
def tomcatInstallPath = "${installRootPath}/tomcat"
cargo {
    containerId = 'tomcat7x'
    port = new Integer(tomcatHttpPort)
    
    deployable{
        // NOTE: Override file to make it pick up an existing war instead of that produce by running other tasks
        // file = file('target/contivo-conversion-service-0.0.1.war')
        context = project.war.baseName + "-${versionName}"
                
        // wait on this URL before continuing
        def pingURL = "http://localhost:${tomcatHttpPort}/${project.war.baseName}/ping"
    }

    local {
        homeDir = file(tomcatInstallPath) // TODO - should this be set from CATALINA_HOME?
        output = file("$buildDir/tomcat-out.log")

        tomcat {
            ajpPort = new Integer(tomcatAjpPort)
        }
         
        // set the initial value
        if(containerJVMArgs) {
            jvmArgs = "$containerJVMArgs"
        } else {
            jvmArgs = ''
        }

        // the leading space is important
        jvmArgs += " -Darchaius.deployment.applicationId=${project.war.baseName}"
        jvmArgs += " -Darchaius.deployment.environment=${deployEnvironment}"
        
        // if containerDebug, append tomcat debug args to jvm args
        if(project.hasProperty('containerDebug')) {
            jvmArgs += ' '
            if (project.hasProperty('suspendDebug')) {
                jvmArgs += containerDebugJVMArgs.replace('suspend=n', 'suspend=y')
            } else {
                jvmArgs += containerDebugJVMArgs
            }
        }
        
        logger.info "=====jvmArgs===="
        logger.info "$jvmArgs"
    }
}

// This is for default config of Tomcat
task configureTomcat(dependsOn: ['stageTomcat']) << {
    //TODO replace tokens would be a nicer but heavier weight way of doing this.
    logger.info "Copying configuring tomcat for environment: ${deployEnvironment}"
    copy {
        from ("${tomcatInstallPath}-configs/common") {
            include '**/*.*'
        }
        into tomcatInstallPath
    }
    copy {
        from ("${tomcatInstallPath}-configs/${deployEnvironment}")  {
            include '**/*.*'
        }
        into tomcatInstallPath
    }
}
project.afterEvaluate {
    cargoRunLocal.dependsOn('configureTomcat')
    cargoStartLocal.dependsOn('configureTomcat')
}


// set properties before starting Jetty (via jettyRun or jettyRunWar)
task jettyRunSetProperties {
    logger.info "Setting jettyRun system properties"
    // use the default port of the ws-backend-simulation module
    System.setProperty('archaius.deployment.applicationId', project.war.baseName)
    System.setProperty('archaius.deployment.environment', "${deployEnvironment}")
    // we only use jettyRun in dev... might as well output log4j debug
    System.setProperty('log4j.debug', 'true') //TODO Is this correct for log4j2 -jfr
}


// jettyRun configuration properties
jettyRun {
    dependsOn 'jettyRunSetProperties'
    logger.info "Running jetty"
    httpPort = new Integer(jettyHttpPort)
    reload = 'automatic'
    scanIntervalSeconds = new Integer(jettyScanIntervalSeconds)
    daemon = false
}

